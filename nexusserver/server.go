package nexusserver

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"os"
	"path"
	"time"

	"github.com/gorilla/mux"
	"github.com/nexus-rpc/sdk-go/nexusapi"
)

type (
	// Options for creating an HTTP handler from a given [Handler].
	Options struct {
		// Handler for handling service requests.
		Handler Handler
		// A stuctured logging handler.
		// Defaults to logging with text format to stderr at info level.
		LogHandler slog.Handler
		// Optional marshaler for marshaling objects to JSON.
		// Defaults to output with indentation.
		Marshaler nexusapi.Marshaler
		// Max duration to allow waiting for a single get result request.
		// Enforced if the provided wait query parameter for a request is greater than this value.
		//
		// Defaults to one minute.
		GetResultMaxRequestTimeout time.Duration
	}

	// Input for [nexusserver.Handler.StartOperation].
	StartOperationRequest struct {
		// Operation name.
		Operation string
		// Request ID, should be used to dedupe start requests.
		RequestID string
		// Callback URL to call upon completion if the started operation is async.
		CallbackURL string
		// The original HTTP request.
		// Read the URL, Header, and Body of the request to process the operation input.
		HTTPRequest *http.Request
	}

	// Input for [nexusserver.Handler.GetOperationResult].
	GetOperationResultRequest struct {
		// Operation name.
		Operation string
		// Operation ID as originally generated by a Handler.
		// It is the handler's responsibility to validate this ID and authorize access to the underlying resource.
		OperationID string
		// Whether the caller has indicated that it wants to wait for operation completion, turning the request into a
		// long poll. When set, the wait duration will be reflected in the provided context deadline.
		Wait bool
		// The original HTTP request.
		HTTPRequest *http.Request
	}

	// Input for [nexusserver.Handler.GetOperationInfo].
	GetOperationInfoRequest struct {
		// Operation name.
		Operation string
		// Operation ID as originally generated by a Handler.
		// It is the handler's responsibility to validate this ID and authorize access to the underlying resource.
		OperationID string
		// The original HTTP request.
		HTTPRequest *http.Request
	}

	// Input for [nexusserver.Handler.CancelOperation].
	CancelOperationRequest struct {
		// Operation name.
		Operation string
		// Operation ID as originally generated by a Handler.
		// It is the handler's responsibility to validate this ID and authorize access to the underlying resource.
		OperationID string
		// The original HTTP request.
		HTTPRequest *http.Request
	}

	// A response to a StartOperation or GetResult request.
	OperationResponse interface {
		applyToStartResponse(http.ResponseWriter, *httpHandler)
		applyToGetResultResponse(http.ResponseWriter, *httpHandler)
	}

	// Return this error from any handler method to fail a request with a custom status code and failure message.
	HandlerError struct {
		// Defaults to 500.
		StatusCode int
		// Failure to report back in the response.
		Failure *nexusapi.Failure
	}

	// A Handler implements all of the Nexus service endpoints as defined in the Nexus HTTP API (https://github.com/nexus-rpc/api).
	Handler interface {
		StartOperation(context.Context, *StartOperationRequest) (OperationResponse, error)
		GetOperationResult(context.Context, *GetOperationResultRequest) (OperationResponse, error)
		GetOperationInfo(context.Context, *GetOperationInfoRequest) (*nexusapi.OperationInfo, error)
		CancelOperation(context.Context, *CancelOperationRequest) error
	}

	baseHTTPHandler struct {
		marshaler nexusapi.Marshaler
		logger    *slog.Logger
	}

	httpHandler struct {
		baseHTTPHandler
		options Options
	}

	// Indicates that an operation completed successfully.
	OperationResponseSync struct {
		// Header to deliver in the HTTP response.
		Header http.Header
		// Body conveying the operation result.
		// If it is an [io.Closer] it will be automatically closed by the framework.
		Body io.Reader
	}

	// Indicates that an operation has been accepted and will complete asynchronously.
	OperationResponseAsync struct {
		OperationID string
	}

	// Input for [nexusserver.CompletionHandler.CompleteOperation].
	CompletionRequest struct {
		// The original HTTP request.
		HTTPRequest *http.Request
		// State of the operation.
		State nexusapi.OperationState
		// Parsed from request and set if State is not failed or canceled.
		Failure *nexusapi.Failure
	}

	// A handler for receiving operation completion requests as delivered via the callback URL provided in start
	// operation requests.
	CompletionHandler interface {
		CompleteOperation(context.Context, *CompletionRequest) error
	}

	// Options for creating an HTTP handler from a given [CompletionHandler].
	CompletionOptions struct {
		// Handler for handling completion requests.
		Handler CompletionHandler
		// A stuctured logging handler.
		// Defaults to logging with text format to stderr at info level.
		LogHandler slog.Handler
		// Optional marshaler for marshaling objects to JSON.
		// Defaults to output with indentation.
		Marshaler nexusapi.Marshaler
	}

	completionHTTPHandler struct {
		baseHTTPHandler
		handler CompletionHandler
	}
)

const (
	headerOperationState = nexusapi.HeaderOperationState
	headerContentType    = nexusapi.HeaderContentType
	contentTypeJSON      = nexusapi.ContentTypeJSON
)

func newBadRequestError(format string, args ...any) *HandlerError {
	return &HandlerError{
		StatusCode: http.StatusBadRequest,
		Failure: &nexusapi.Failure{
			Message: fmt.Sprintf(format, args...),
		},
	}
}

// Error implements the error interface.
func (e *HandlerError) Error() string {
	return fmt.Sprintf("%d: %s", e.StatusCode, e.Failure.Message)
}

func (r *OperationResponseAsync) applyToStartResponse(writer http.ResponseWriter, handler *httpHandler) {
	info := nexusapi.OperationInfo{
		ID:    r.OperationID,
		State: nexusapi.OperationStateRunning,
	}
	bytes, err := handler.marshaler(info)
	if err != nil {
		handler.logger.Error("failed to serialize operation info", "error", err)
		writer.WriteHeader(http.StatusInternalServerError)
		return
	}

	writer.Header().Set(headerContentType, contentTypeJSON)
	writer.WriteHeader(http.StatusCreated)

	if _, err := writer.Write(bytes); err != nil {
		handler.logger.Error("failed to write response body", "error", err)
	}
}

func (r *OperationResponseAsync) applyToGetResultResponse(writer http.ResponseWriter, handler *httpHandler) {
	writer.Header().Set(headerOperationState, string(nexusapi.OperationStateRunning))
	writer.WriteHeader(http.StatusNoContent)
}

func (r *OperationResponseSync) applyToStartResponse(writer http.ResponseWriter, handler *httpHandler) {
	header := writer.Header()
	for k, v := range r.Header {
		header[k] = v
	}
	if closer, ok := r.Body.(io.Closer); ok {
		defer closer.Close()
	}
	if _, err := io.Copy(writer, r.Body); err != nil {
		handler.logger.Error("failed to write response body", "error", err)
	}
}

func (r *OperationResponseSync) applyToGetResultResponse(writer http.ResponseWriter, handler *httpHandler) {
	writer.Header().Set(headerOperationState, string(nexusapi.OperationStateSucceeded))
	r.applyToStartResponse(writer, handler)
}

// NewJSONOperationResponseSync constructs an [OperationResponseSync], setting the proper Content-Type header.
// Marhsals the provided value to JSON using [nexusapi.DefaultMarshaler].
func NewJSONOperationResponseSync(v any) (*OperationResponseSync, error) {
	b, err := nexusapi.DefaultMarshaler(v)
	if err != nil {
		return nil, err
	}
	header := make(http.Header)
	header.Set(headerContentType, contentTypeJSON)
	return &OperationResponseSync{
		Header: header,
		Body:   bytes.NewReader(b),
	}, nil
}

func (h *baseHTTPHandler) writeFailure(writer http.ResponseWriter, err error) {
	var failure *nexusapi.Failure
	var unsuccessfulError *nexusapi.UnsuccessfulOperationError
	var handlerError *HandlerError
	var operationState nexusapi.OperationState
	statusCode := http.StatusInternalServerError

	if errors.As(err, &unsuccessfulError) {
		operationState = unsuccessfulError.State
		failure = unsuccessfulError.Failure
		statusCode = nexusapi.StatusOperationFailed

		if operationState == nexusapi.OperationStateFailed || operationState == nexusapi.OperationStateCanceled {
			writer.Header().Set(headerOperationState, string(operationState))
		} else {
			h.logger.Error("unexpected operation state", "state", operationState)
			writer.WriteHeader(http.StatusInternalServerError)
			return
		}
	} else if errors.As(err, &handlerError) {
		failure = handlerError.Failure
		statusCode = handlerError.StatusCode
	} else {
		failure = &nexusapi.Failure{
			Message: "internal server error",
		}
		h.logger.Error("handler failed", "error", err)
	}

	var bytes []byte
	if failure != nil {
		bytes, err = h.marshaler(failure)
		if err != nil {
			h.logger.Error("failed to marshal failure", "error", err)
			writer.WriteHeader(http.StatusInternalServerError)
			return
		}
		writer.Header().Set(headerContentType, contentTypeJSON)
	}

	writer.WriteHeader(statusCode)

	if _, err := writer.Write(bytes); err != nil {
		h.logger.Error("failed to write response body", "error", err)
	}
}

func (h *httpHandler) startOperation(writer http.ResponseWriter, request *http.Request) {
	operation := path.Base(request.URL.Path)
	handlerRequest := &StartOperationRequest{
		Operation:   operation,
		RequestID:   request.Header.Get(nexusapi.HeaderRequestID),
		CallbackURL: request.URL.Query().Get(nexusapi.QueryCallbackURL),
		HTTPRequest: request,
	}
	response, err := h.options.Handler.StartOperation(request.Context(), handlerRequest)
	if err != nil {
		h.writeFailure(writer, err)
	} else {
		response.applyToStartResponse(writer, h)
	}
}

func (h *httpHandler) getOperationResult(writer http.ResponseWriter, request *http.Request) {
	// strip /result
	prefix, operationID := path.Split(path.Dir(request.URL.Path))
	operation := path.Base(prefix)
	handlerRequest := &GetOperationResultRequest{Operation: operation, OperationID: operationID, HTTPRequest: request}

	ctx := request.Context()
	waitStr := request.URL.Query().Get(nexusapi.QueryWait)
	if waitStr != "" {
		waitDuration, err := time.ParseDuration(waitStr)
		if err != nil {
			h.logger.Warn("invalid wait duration query parameter", "wait", waitStr)
			h.writeFailure(writer, newBadRequestError("invalid wait query parameter"))
			return
		}

		var cancel func()
		if waitDuration > h.options.GetResultMaxRequestTimeout {
			waitDuration = h.options.GetResultMaxRequestTimeout
		}
		// TODO: reduce duration a bit to give some grace time?
		ctx, cancel = context.WithTimeout(ctx, waitDuration)
		handlerRequest.Wait = true
		defer cancel()
	}

	response, err := h.options.Handler.GetOperationResult(ctx, handlerRequest)
	if err != nil {
		if handlerRequest.Wait && errors.Is(err, context.DeadlineExceeded) {
			// Convert deadline exceeded to an async response to simplify handler implementation.
			response = &OperationResponseAsync{OperationID: handlerRequest.OperationID}
		} else {
			h.writeFailure(writer, err)
			return
		}
	}
	response.applyToGetResultResponse(writer, h)
}

func (h *httpHandler) getOperationInfo(writer http.ResponseWriter, request *http.Request) {
	prefix, operationID := path.Split(request.URL.Path)
	operation := path.Base(prefix)
	handlerRequest := &GetOperationInfoRequest{Operation: operation, OperationID: operationID, HTTPRequest: request}

	info, err := h.options.Handler.GetOperationInfo(request.Context(), handlerRequest)
	if err != nil {
		h.writeFailure(writer, err)
		return
	}

	bytes, err := h.options.Marshaler(info)
	if err != nil {
		h.writeFailure(writer, fmt.Errorf("failed to marshal operation info: %w", err))
		return
	}
	writer.Header().Set(headerContentType, contentTypeJSON)
	if _, err := writer.Write(bytes); err != nil {
		h.logger.Error("failed to write response body", "error", err)
	}
}

func (h *httpHandler) CancelOperation(writer http.ResponseWriter, request *http.Request) {
	// strip /cancel
	prefix, operationID := path.Split(path.Dir(request.URL.Path))
	operation := path.Base(prefix)
	handlerRequest := &CancelOperationRequest{Operation: operation, OperationID: operationID, HTTPRequest: request}

	if err := h.options.Handler.CancelOperation(request.Context(), handlerRequest); err != nil {
		h.writeFailure(writer, err)
		return
	}

	writer.WriteHeader(http.StatusAccepted)
}

// Constructs an [http.Handler] from given options for handling Nexus service requests.
func NewHTTPHandler(options Options) http.Handler {
	if options.Marshaler == nil {
		options.Marshaler = nexusapi.DefaultMarshaler
	}
	if options.LogHandler == nil {
		options.LogHandler = newDefaultLogHandler()
	}
	if options.GetResultMaxRequestTimeout == 0 {
		options.GetResultMaxRequestTimeout = time.Minute
	}
	handler := &httpHandler{
		baseHTTPHandler: baseHTTPHandler{
			logger:    slog.New(options.LogHandler),
			marshaler: options.Marshaler,
		},
		options: options,
	}

	router := mux.NewRouter()
	router.HandleFunc("/{operation}", handler.startOperation).Methods("POST")
	router.HandleFunc("/{operation}/{operation_id}", handler.getOperationInfo).Methods("GET")
	router.HandleFunc("/{operation}/{operation_id}/result", handler.getOperationResult).Methods("GET")
	router.HandleFunc("/{operation}/{operation_id}/cancel", handler.CancelOperation).Methods("POST")
	return router
}

func (h *completionHTTPHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {
	ctx := request.Context()
	completion := CompletionRequest{
		State:       nexusapi.OperationState(request.Header.Get(headerOperationState)),
		HTTPRequest: request,
	}
	switch completion.State {
	case nexusapi.OperationStateFailed, nexusapi.OperationStateCanceled:
		if !nexusapi.IsContentTypeJSON(request.Header) {
			h.writeFailure(writer, newBadRequestError("invalid request content type: %q", request.Header.Get(headerContentType)))
			return
		}
		var failure nexusapi.Failure
		b, err := io.ReadAll(request.Body)
		if err != nil {
			h.writeFailure(writer, newBadRequestError("failed to read Failure from request body"))
			return
		}
		if err := json.Unmarshal(b, &failure); err != nil {
			h.writeFailure(writer, newBadRequestError("failed to read Failure from request body"))
			return
		}
		completion.Failure = &failure
	case nexusapi.OperationStateSucceeded:
		// Nothing to do here.
	default:
		h.writeFailure(writer, newBadRequestError("invalid request operation state: %q", completion.State))
		return
	}
	if err := h.handler.CompleteOperation(ctx, &completion); err != nil {
		h.writeFailure(writer, err)
	}
}

// Constructs an [http.Handler] from given options for handling operation completion requests.
func NewCompletionHTTPHandler(options CompletionOptions) http.Handler {
	if options.Marshaler == nil {
		options.Marshaler = nexusapi.DefaultMarshaler
	}
	if options.LogHandler == nil {
		options.LogHandler = newDefaultLogHandler()
	}
	return &completionHTTPHandler{
		baseHTTPHandler: baseHTTPHandler{
			logger:    slog.New(options.LogHandler),
			marshaler: options.Marshaler,
		},
		handler: options.Handler,
	}
}

func newDefaultLogHandler() slog.Handler {
	return slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelInfo})
}
