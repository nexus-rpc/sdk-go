package nexus

import (
	"encoding/json"
	"fmt"
)

// A Failure represents failed handler invocations as well as `failed` or `canceled` operation results. Failures
// shouldn't typically be constructed directly. The SDK APIs take a [FailureConverter] instance that can translate
// language errors to and from [Failure] instances.
type Failure struct {
	// A simple text message.
	Message string `json:"message,omitempty"`
	// Stack trace which may be set if this error was generated by a language that supports it.
	StackTrace string `json:"stackTrace,omitempty"`
	// A key-value mapping for additional context. Useful for decoding the 'details' field, if needed.
	Metadata map[string]string `json:"metadata,omitempty"`
	// Additional JSON serializable structured data.
	Details json.RawMessage `json:"details,omitempty"`
	// An optional nested cause.
	Cause *Failure `json:"cause,omitempty"`
}

// An error that directly represents a wire representation of [Failure].
// The SDK will convert to this error by default unless the [FailureConverter] instance is customized.
type FailureError struct {
	// The underlying Failure object this error represents.
	Failure Failure
	// An optional nested cause.
	Cause error
}

// Error implements the error interface.
func (e *FailureError) Error() string {
	return e.Failure.Message
}

// Unwrap implements the error interface.
func (e *FailureError) Unwrap() error {
	return e.Cause
}

// FailureConverter is used by the framework to transform [error] instances to and from [Failure] instances.
// To customize conversion logic, implement this interface and provide your implementation to framework methods such as
// [NewHTTPClient] and [NewHTTPHandler].
// By default the SDK translates [HandlerError], [OperationError] and [FailureError] to and from [Failure]
// objects maintaining their cause chain.
// Arbitrary errors are translated to a [Failure] object with its Message set to the Error() string, losing the cause
// chain.
type FailureConverter interface {
	// ErrorToFailure converts an [error] to a [Failure].
	// Note that the provided error may be nil.
	ErrorToFailure(error) (Failure, error)
	// FailureToError converts a [Failure] to an [error].
	FailureToError(Failure) (error, error)
}

type knownErrorFailureConverter struct{}

type serializedHandlerError struct {
	Type              string `json:"type,omitempty"`
	RetryableOverride *bool  `json:"retryableOverride,omitempty"`
}

func (e serializedHandlerError) RetryBehavior() HandlerErrorRetryBehavior {
	if e.RetryableOverride == nil {
		return HandlerErrorRetryBehaviorUnspecified
	}
	if *e.RetryableOverride {
		return HandlerErrorRetryBehaviorRetryable
	} else {
		return HandlerErrorRetryBehaviorNonRetryable
	}
}

type serializedOperationError struct {
	State string `json:"state,omitempty"`
}

// ErrorToFailure implements FailureConverter.
func (e knownErrorFailureConverter) ErrorToFailure(err error) (Failure, error) {
	if err == nil {
		return Failure{}, nil
	}
	// NOTE: not using errors.Unwrap here we are intentionally only supporting unwrapping known errors.
	switch typedErr := err.(type) {
	case *FailureError:
		f := typedErr.Failure
		// Convert the erorr cause if set and failure cause is not already set.
		if typedErr.Cause != nil && f.Cause == nil {
			c, err := e.ErrorToFailure(typedErr.Cause)
			if err != nil {
				return Failure{}, err
			}
			f.Cause = &c
		}
		return f, nil
	case *HandlerError:
		if typedErr.OriginalFailure != nil {
			return *typedErr.OriginalFailure, nil
		}
		// Temporary workaround for compatibility with old SDKs that don't support handler error messages.
		if typedErr.Message == "" && typedErr.Cause != nil {
			return e.ErrorToFailure(typedErr.Cause)
		}
		data := serializedHandlerError{
			Type:              string(typedErr.Type),
			RetryableOverride: typedErr.retryBehaviorAsOptionalBool(),
		}
		var details []byte
		details, err := json.Marshal(data)
		if err != nil {
			return Failure{}, err
		}
		f := Failure{
			Message:    typedErr.Message,
			StackTrace: typedErr.StackTrace,
			Metadata: map[string]string{
				"type": "nexus.HandlerError",
			},
			Details: details,
		}

		if typedErr.Cause != nil {
			c, err := e.ErrorToFailure(typedErr.Cause)
			if err != nil {
				return Failure{}, err
			}
			f.Cause = &c
		}

		return f, nil
	case *OperationError:
		if typedErr.OriginalFailure != nil {
			return *typedErr.OriginalFailure, nil
		}
		// Temporary workaround for compatibility with old SDKs that don't support operation error messages.
		if typedErr.Message == "" && typedErr.Cause != nil {
			return e.ErrorToFailure(typedErr.Cause)
		}
		data := serializedOperationError{
			State: string(typedErr.State),
		}
		details, err := json.Marshal(data)
		if err != nil {
			return Failure{}, err
		}
		f := Failure{
			Message:    typedErr.Message,
			StackTrace: typedErr.StackTrace,
			Metadata: map[string]string{
				"type": "nexus.OperationError",
			},
			Details: details,
		}

		if typedErr.Cause != nil {
			c, err := e.ErrorToFailure(typedErr.Cause)
			if err != nil {
				return Failure{}, err
			}
			f.Cause = &c
		}
		return f, nil
	default:
		return Failure{
			Message: typedErr.Error(),
		}, nil
	}
}

// FailureToError implements FailureConverter.
func (e knownErrorFailureConverter) FailureToError(f Failure) (error, error) {
	if f.Metadata != nil {
		switch f.Metadata["type"] {
		case "nexus.HandlerError":
			var se serializedHandlerError
			err := json.Unmarshal(f.Details, &se)
			if err != nil {
				return nil, fmt.Errorf("failed to deserialize HandlerError: %w", err)
			}
			he := &HandlerError{
				Message:         f.Message,
				StackTrace:      f.StackTrace,
				Type:            HandlerErrorType(se.Type),
				RetryBehavior:   se.RetryBehavior(),
				OriginalFailure: &f,
			}
			if f.Cause != nil {
				he.Cause, err = e.FailureToError(*f.Cause)
				if err != nil {
					return nil, err
				}
			}
			return he, nil
		case "nexus.OperationError":
			var se serializedOperationError
			err := json.Unmarshal(f.Details, &se)
			if err != nil {
				return nil, fmt.Errorf("failed to deserialize OperationError: %w", err)
			}
			oe := &OperationError{
				Message:         f.Message,
				StackTrace:      f.StackTrace,
				State:           OperationState(se.State),
				OriginalFailure: &f,
			}
			if f.Cause != nil {
				oe.Cause, err = e.FailureToError(*f.Cause)
				if err != nil {
					return nil, err
				}
			}
			return oe, nil
		}
	}
	// Note that the original failure cause is retained on the FailureError's failure object.
	fe := &FailureError{Failure: f}
	if f.Cause != nil {
		c, err := e.FailureToError(*f.Cause)
		if err != nil {
			return nil, err
		}
		fe.Cause = c
	}
	return fe, nil
}

var defaultFailureConverter FailureConverter = knownErrorFailureConverter{}

// DefaultFailureConverter returns the SDK's default [FailureConverter] implementation. Translates [HandlerError],
// [OperationError] and [FailureError] to and from [Failure] objects maintaining their cause chain.
// Arbitrary errors are translated to a [Failure] object with its Message set to the Error() string, losing the cause
// chain.
// [Failure] instances are converted to [FailureError] to allow access to the full failure metadata and details if
// available.
func DefaultFailureConverter() FailureConverter {
	return defaultFailureConverter
}
