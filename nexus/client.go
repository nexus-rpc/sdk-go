package nexus

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	"github.com/google/uuid"
)

// ClientOptions are options for creating a Client.
type ClientOptions struct {
	// Base URL of the service.
	// Optional. If not provided, this client can only be used to deliver operation completions.
	ServiceBaseURL string
	// An function for making HTTP requests.
	// Defaults to [http.DefaultClient.Do].
	HTTPCaller func(*http.Request) (*http.Response, error)
	// Max duration to wait for a single get result request.
	// Enforced if context deadline for the request is unset or greater than this value.
	//
	// Defaults to one minute.
	GetResultMaxTimeout time.Duration
	// Optional marshaler for marshaling objects to JSON.
	// Defaults to json.Marshal.
	Marshaler func(any) ([]byte, error)
}

// A Client is used to start an operation, get an [OperationHandle] to an existing operation, and deliver operation
// completions.
type Client struct {
	// The options this client was created with after applying defaults.
	Options        ClientOptions
	serviceBaseURL *url.URL
}

// Package version.
const Version = "dev" // TODO: Actual version as part of the release tagging process.

// User-Agent header set on HTTP requests.
const UserAgent = "Nexus-go-sdk/" + Version

// Error indicating an empty ServiceBaseURL option was used to create a client when making a Nexus service request.
var errEmptyServiceBaseURL = errors.New("empty serviceBaseURL")

// Error indicating a non HTTP URL was used to create a [Client].
var errInvalidURLScheme = errors.New("invalid URL scheme")

// Asynchronous method was used on an [OperationHandle] representing a synchronous operation.
var errHandleForSyncOperation = errors.New("handle represents a synchronous operation")

var errOperationStillRunning = errors.New("operation still running")

const headerUserAgent = "User-Agent"

// Error that indicates a client encountered something unexpected in the server's response.
type UnexpectedResponseError struct {
	// Error message.
	Message string
	// The HTTP response. The response body will have already been read into memory and there is no need to close it.
	Response *http.Response
	// Optional failure that may have been emedded in the HTTP response body.
	Failure *Failure
}

// Error implements the error interface.
func (e *UnexpectedResponseError) Error() string {
	return e.Message
}

func newUnexpectedResponseError(message string, response *http.Response, body []byte) error {
	var failure *Failure
	if isContentTypeJSON(response.Header) {
		if err := json.Unmarshal(body, failure); err == nil && failure.Message != "" {
			message += ": " + failure.Message
		}
	}

	return &UnexpectedResponseError{
		Message:  message,
		Response: response,
		Failure:  failure,
	}
}

// New creates a new [Client] from provided [Options].
// None of the options are required. Provide BaseServiceURL if you intend to use this client to make Nexus service calls
// or leave empty when using this client only to deliver completions.
func New(options ClientOptions) (*Client, error) {
	if options.HTTPCaller == nil {
		options.HTTPCaller = http.DefaultClient.Do
	}
	var serviceBaseURL *url.URL
	if options.ServiceBaseURL != "" {
		var err error
		serviceBaseURL, err = url.Parse(options.ServiceBaseURL)
		if err != nil {
			return nil, err
		}
		if serviceBaseURL.Scheme != "http" && serviceBaseURL.Scheme != "https" {
			return nil, errInvalidURLScheme
		}
	}
	if options.GetResultMaxTimeout == 0 {
		options.GetResultMaxTimeout = time.Minute
	}
	if options.Marshaler == nil {
		options.Marshaler = json.Marshal
	}

	return &Client{
		Options:        options,
		serviceBaseURL: serviceBaseURL,
	}, nil
}

// Input for [nexusclient.Client.StartOperation].
type StartOperationRequest struct {
	// Name of the operation to start.
	Operation string
	// Callback URL to provide to the handle for receiving async operation completions. Optional.
	CallbackURL string
	// Request ID that may be used by the server handler to dedupe this start request.
	// By default a v4 UUID will be generated by the client.
	RequestID string
	// Header to attach to the HTTP request. Optional.
	Header http.Header
	// Body of the operation request.
	// If it is an [io.Closer], the body will be automatically closed by the client.
	Body io.Reader
}

// NewJSONStartOperationRequest is shorthand for creating a StartOperationRequest with a JSON body.
// Marhsals the provided value to JSON using [json.Marshal].
func NewJSONStartOperationRequest(operation string, v any) (request StartOperationRequest, err error) {
	req := StartOperationRequest{}
	var b []byte
	b, err = json.Marshal(v)
	if err != nil {
		return
	}
	req.Operation = operation
	req.Header = http.Header{headerContentType: []string{contentTypeJSON}}
	req.Body = bytes.NewReader(b)
	return
}

// StartOperationResult is the return value of [Client.StartOperation].
// It represents the mutually exclusive Successful and Pending outcomes of that method.
type StartOperationResult struct {
	// Set when start completes synchronously and successfully.
	//
	// ⚠️ The response body must be read in its entirety and closed to free up the underlying connection.
	Successful *http.Response
	// Set when the handler indicates that it started an asynchronous operation.
	// The attached handle can be used to perform actions such as cancel the operation or get its result.
	Pending *OperationHandle
}

// StartOperation calls the configured Nexus endpoint to start an operation.
//
// This method has the following possible outcomes:
//
// 1. The operation completes successfully. The HTTP response of this call will be set as
// [StartOperationResult.Successful] and its body must be read in its entirety and closed to free up the underlying
// connection.
//
// 2. The operation completes unsuccessfully. The returned result will be nil and error will be an
// [UnsuccessfulOperationError].
//
// 3. The operation was started and the handler has indicated that it will complete asynchronously. An [OperationHandle]
// will be returned a [StartOperationResult.Pending], which can be used to perform actions such as getting its result.
//
// 4. Any other failure.
func (c *Client) StartOperation(ctx context.Context, request StartOperationRequest) (*StartOperationResult, error) {
	if closer, ok := request.Body.(io.Closer); ok {
		// Close the request body in case we error before sending the HTTP request (which may double close but that's fine since we ignore the error).
		defer closer.Close()
	}
	url, err := c.joinURL(request.Operation)
	if err != nil {
		return nil, err
	}
	if request.CallbackURL != "" {
		q := url.Query()
		q.Set(QueryCallbackURL, request.CallbackURL)
		url.RawQuery = q.Encode()
	}
	httpReq, err := http.NewRequestWithContext(ctx, "POST", url.String(), request.Body)
	if err != nil {
		return nil, err
	}

	if request.Header != nil {
		httpReq.Header = request.Header.Clone()
	}
	if request.RequestID == "" {
		requestIDFromHeader := request.Header.Get(HeaderRequestID)
		if requestIDFromHeader != "" {
			request.RequestID = requestIDFromHeader
		} else {
			request.RequestID = uuid.NewString()
		}
	}
	httpReq.Header.Set(HeaderRequestID, request.RequestID)
	httpReq.Header.Set(headerUserAgent, UserAgent)

	response, err := c.Options.HTTPCaller(httpReq)
	if err != nil {
		return nil, err
	}
	// Do not close response body here to allow successful result to read it.
	if response.StatusCode == http.StatusOK || response.StatusCode == http.StatusNoContent {
		return &StartOperationResult{
			Successful: response,
		}, nil
	}

	// Do this once here and make sure it doesn't leak.
	body, err := readAndReplaceBody(response)
	if err != nil {
		return nil, err
	}

	switch response.StatusCode {
	case http.StatusCreated:
		info, err := operationInfoFromResponse(response, body)
		if err != nil {
			return nil, err
		}
		if info.State != OperationStateRunning {
			return nil, newUnexpectedResponseError(fmt.Sprintf("invalid operation state in response info: %q", info.State), response, body)
		}
		return &StartOperationResult{
			Pending: &OperationHandle{
				Operation: request.Operation,
				ID:        info.ID,
				client:    c,
			},
		}, nil
	case StatusOperationFailed:
		state, err := getUnsuccessfulStateFromHeader(response, body)
		if err != nil {
			return nil, err
		}

		failure, err := failureFromResponse(response, body)
		if err != nil {
			return nil, err
		}

		return nil, &UnsuccessfulOperationError{
			State:   state,
			Failure: failure,
		}
	default:
		return nil, newUnexpectedResponseError(fmt.Sprintf("unexpected response status: %q", response.Status), response, body)
	}
}

// Input for [nexusclient.Client.ExecuteOperation].
type ExecuteOperationRequest struct {
	// Name of the operation to start.
	Operation string
	// Callback URL to provide to the handle for receiving async operation completions. Optional.
	// While [Client.ExecuteOperation] waits for operation completion, some application may want to set this callback as
	// a fallback mechanism.
	CallbackURL string
	// Request ID that may be used by the server handler to dedupe this start request.
	// By default a v4 UUID will be generated by the client.
	RequestID string
	// Header to attach to the start HTTP request. Optional.
	StartHeader http.Header
	// Body of the operation request.
	// If it is an [io.Closer], the body will be automatically closed by the client.
	Body io.Reader
	// Header to attach to the get-result HTTP request. Optional.
	GetResultHeader http.Header
}

func (r *ExecuteOperationRequest) intoStartRequest() StartOperationRequest {
	return StartOperationRequest{
		Operation:   r.Operation,
		CallbackURL: r.CallbackURL,
		RequestID:   r.RequestID,
		Header:      r.StartHeader,
		Body:        r.Body,
	}
}

func (r *ExecuteOperationRequest) intoGetResultOptions() GetResultOptions {
	return GetResultOptions{
		Header: r.GetResultHeader,
		Wait:   true,
	}
}

// ExecuteOperation is a helper for starting an operation and waiting for its completion.
// If the the result is delivered synchronously in the start response, it is delivered directly.
// Otherwise, this method will long poll until the result is ready or the context deadline exceeds.
func (c *Client) ExecuteOperation(ctx context.Context, request ExecuteOperationRequest) (*http.Response, error) {
	result, err := c.StartOperation(ctx, request.intoStartRequest())
	if err != nil {
		return nil, err
	}
	if result.Successful != nil {
		return result.Successful, nil
	}
	handle := result.Pending
	return handle.GetResult(ctx, request.intoGetResultOptions())
}

// NewHandle gets a handle to an asynchronous operation by name and ID.
// Does not incur a trip to the server.
func (c *Client) NewHandle(operation string, operationID string) *OperationHandle {
	return &OperationHandle{
		client:    c,
		Operation: operation,
		ID:        operationID,
	}
}

func (c *Client) sendGetOperationResultRequest(ctx context.Context, httpReq *http.Request, wait bool) (*http.Response, error) {
	if wait {
		timeout := c.Options.GetResultMaxTimeout
		if deadline, set := ctx.Deadline(); set {
			timeout = time.Until(deadline)
			if timeout > c.Options.GetResultMaxTimeout {
				timeout = c.Options.GetResultMaxTimeout
			}
		}

		url := httpReq.URL
		q := url.Query()
		q.Set(QueryWait, fmt.Sprintf("%dms", timeout.Milliseconds()))
		url.RawQuery = q.Encode()
	}

	response, err := c.Options.HTTPCaller(httpReq)
	if err != nil {
		return nil, err
	}

	if response.StatusCode == http.StatusOK {
		return response, nil
	}

	// Do this once here and make sure it doesn't leak.
	body, err := readAndReplaceBody(response)
	if err != nil {
		return nil, err
	}

	switch response.StatusCode {
	case http.StatusNoContent:
		state := OperationState(response.Header.Get(HeaderOperationState))

		switch state {
		case OperationStateRunning:
			return nil, errOperationStillRunning
		case OperationStateSucceeded:
			return response, nil
		default:
			return nil, newUnexpectedResponseError(fmt.Sprintf("unexpected operation state: %s", state), response, body)
		}
	case StatusOperationFailed:
		state, err := getUnsuccessfulStateFromHeader(response, body)
		if err != nil {
			return nil, err
		}
		failure, err := failureFromResponse(response, body)
		if err != nil {
			return nil, err
		}
		return nil, &UnsuccessfulOperationError{
			State:   state,
			Failure: failure,
		}
	default:
		return nil, newUnexpectedResponseError(fmt.Sprintf("unexpected response status: %q", response.Status), response, body)
	}
}

// DeliverCompletion delivers the result of a completed asynchronous operation to the provided URL.
// If completion is a [OperationCompletionSuccessful] its body will be automatically closed.
func (c *Client) DeliverCompletion(ctx context.Context, url string, completion OperationCompletion) error {
	// while the http client is expected to close the body, we close in case request creation fails (which may double close but that's fine since we ignore the error).
	defer completion.Close()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return err
	}
	if err := completion.applyToHTTPRequest(httpReq, c); err != nil {
		return err
	}

	httpReq.Header.Set(headerUserAgent, UserAgent)
	response, err := c.Options.HTTPCaller(httpReq)
	if err != nil {
		return err
	}

	// Do this once here and make sure it doesn't leak.
	body, err := readAndReplaceBody(response)
	if err != nil {
		return err
	}

	if response.StatusCode != http.StatusOK {
		return newUnexpectedResponseError(fmt.Sprintf("unexpected response status: %q", response.Status), response, body)
	}

	return nil
}

func (c *Client) joinURL(parts ...string) (*url.URL, error) {
	if c.serviceBaseURL == nil {
		return nil, errEmptyServiceBaseURL
	}
	return c.serviceBaseURL.JoinPath(parts...), nil
}

// OperationCompletion is input for [nexusclient.Client.CompletionOperation].
// It has two implementations: [OperationCompletionSuccessful] and [OperationCompletionUnsuccessful].
type OperationCompletion interface {
	io.Closer
	applyToHTTPRequest(*http.Request, *Client) error
}

// OperationCompletionSuccessful is input for [nexusclient.Client.CompletionOperation] to deliver successful operation
// results.
type OperationCompletionSuccessful struct {
	// Header to send in the completion request.
	Header http.Header
	// Body to send in the completion HTTP request.
	// If it implements `io.Closer` it will automatically be closed by the client
	Body io.Reader
}

// OperationCompletionUnsuccessful is input for [nexusclient.Client.CompletionOperation] to deliver unsuccessful
// operation results.
type OperationCompletionUnsuccessful struct {
	// Header to send in the completion request.
	Header http.Header
	// State of the operation, should be failed or canceled.
	State OperationState
	// Failure object to send with the completion.
	Failure *Failure
}

// NewJSONSuccessfulOperationCompletion constructs an [OperationCompletionSuccessful] from a JSONable value.
// Marhsals the provided value to JSON using [json.Marshal].
func NewJSONSuccessfulOperationCompletion(v any) (*OperationCompletionSuccessful, error) {
	b, err := json.Marshal(v)
	if err != nil {
		return nil, err
	}

	header := make(http.Header, 1)
	header.Set(headerContentType, contentTypeJSON)

	return &OperationCompletionSuccessful{
		Header: header,
		Body:   io.NopCloser(bytes.NewReader(b)),
	}, nil
}

func (c *OperationCompletionSuccessful) applyToHTTPRequest(request *http.Request, client *Client) error {
	if c.Header != nil {
		request.Header = c.Header.Clone()
	}
	request.Header.Set(HeaderOperationState, string(OperationStateSucceeded))
	if closer, ok := c.Body.(io.ReadCloser); ok {
		request.Body = closer
	} else {
		request.Body = io.NopCloser(c.Body)
	}
	return nil
}

// Close implements the io.Closer interface.
func (c *OperationCompletionSuccessful) Close() error {
	if closer, ok := c.Body.(io.Closer); ok {
		return closer.Close()
	}
	return nil
}

func (c *OperationCompletionUnsuccessful) applyToHTTPRequest(request *http.Request, client *Client) error {
	if c.Header != nil {
		request.Header = c.Header.Clone()
	}
	request.Header.Set(HeaderOperationState, string(c.State))
	request.Header.Set(headerContentType, contentTypeJSON)

	b, err := client.Options.Marshaler(c.Failure)
	if err != nil {
		return err
	}

	request.Body = io.NopCloser(bytes.NewReader(b))
	return nil
}

// Close implements the io.Closer interface.
func (c *OperationCompletionUnsuccessful) Close() error {
	return nil
}

// readAndReplaceBody reads the response body in its entirety and closes it, and then replaces the original response
// body with an in-memory buffer.
func readAndReplaceBody(response *http.Response) ([]byte, error) {
	responseBody := response.Body
	defer responseBody.Close()
	body, err := io.ReadAll(responseBody)
	if err != nil {
		return nil, err
	}
	response.Body = io.NopCloser(bytes.NewReader(body))
	return body, nil
}

func operationInfoFromResponse(response *http.Response, body []byte) (*OperationInfo, error) {
	if !isContentTypeJSON(response.Header) {
		return nil, newUnexpectedResponseError(fmt.Sprintf("invalid response content type: %q", response.Header.Get(headerContentType)), response, body)
	}
	var info OperationInfo
	if err := json.Unmarshal(body, &info); err != nil {
		return nil, err
	}
	return &info, nil
}

func failureFromResponse(response *http.Response, body []byte) (*Failure, error) {
	if !isContentTypeJSON(response.Header) {
		return nil, newUnexpectedResponseError(fmt.Sprintf("invalid response content type: %q", response.Header.Get(headerContentType)), response, body)
	}
	var failure Failure
	if err := json.Unmarshal(body, &failure); err != nil {
		return nil, err
	}
	return &failure, nil
}

func getUnsuccessfulStateFromHeader(response *http.Response, body []byte) (OperationState, error) {
	state := OperationState(response.Header.Get(HeaderOperationState))
	switch state {
	case OperationStateCanceled:
		return state, nil
	case OperationStateFailed:
		return state, nil
	default:
		return state, newUnexpectedResponseError(fmt.Sprintf("invalid operation state header: %q", state), response, body)
	}
}
